# Accessing Data with JPA
[Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/)

## Understanding POJOs
POJO 는 __Plain Old Java Object__ 의 준말이다. 이는 프레임워크에 의해 의존하고 있지 않은 순수 자바 객체를 의미한다. 자바 메세지 서비스(Java Message Service) JMS 에서 MessageListener 인터페이스를 구현한 클래스를 작성한다고 예를 들자.
```JAVA
public class ExampleListener implements MessageListener {

    public void onMessage(Message message) {
        if (message instanceof TextMessage) {
            try {
                System.out.println(((TextMessage) message).getText());
            }
            catch (JMSException ex) {
                throw new RuntimeException(ex);
            }
        }
        else {
            throw new IllegalArgumentException("Message must be of type TextMessage");
        }
    }

}
```
위의 예에서는 JMS에 코드가 묶여버려 나중에 대체 메세지로 마이그레이션하기 어려워진다. POJO 기반 접근은 인터페이스가 없는 메시지 처리 솔루션을 작성함을 의미한다.
```JAVA
@Component
public class ExampleListener {

    @JmsListener(destination = "myDestination")
    public void processOrder(String message) {
    	System.out.println(message);
    }
}
```
위의 예시에서 코드가 인터페이스에 직접적인 연결을 하지 않는다. 대신 JMS 에 연결하는 책임은 애노테이션으로 변환되며 이후에 쉽게 업데이트 할 수 있다. @JmsListener 를 @RabbitListener 로 바꿀 수 있음을 의미한다. 결국 다른 상황에서 특정한 애노테이션이 없어도 POJO 기반 솔루션을 이용할 수 있는 것이다. 결과적으로 테스트와 유연성에서 POJO 를 기반으로 한 접근이 더 필요해질 것이다.

### POJO에 대한 추가 내용 
다른 곳에 종속되지 않는다는 것은 해당 클래스를 사용하기 위해 다른 프레임워크 같은 외부환경이 필요하지 않음을 뜻한다. 또한 해당 환경이 특정 인터페이스를 구현하는 것에 대한 강요를 받는 것이 사라지며 그와 같은 제약에 자유로움을 뜻한다.   
   
이는 2.X 버전 이전의 EJB와 대비해서 강조되던 내용이고, 스프링을 "경량 프레임워크" 라고 부른 것과도 같은 맥락의 이야기이다. __따라서 애플리케이션 서버 같은 외부 구동환경과 무관한 비즈니스 계층의 다른 클래스를 상속하거나 구현하더라도 POJO 라고 부르는데 문제가 생기는 것은 아님을 명확히 한다.__   
   
__결과적으로 Spring MVC 를 걷어내도 POJO들은 정상적으로 작동이 되어야 한다는 것__
- [참고링크](https://jojoldu.tistory.com/28)


